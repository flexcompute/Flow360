"""
Regression tests for boundary_split.py
"""

from unittest.mock import MagicMock

import pytest

from flow360.component.simulation.entity_info import (
    GeometryEntityInfo,
    VolumeMeshEntityInfo,
)
from flow360.component.simulation.framework.boundary_split import (
    BoundaryNameLookupTable,
    RotationVolumeSplitProvider,
    SplitType,
)
from flow360.component.simulation.framework.entity_base import EntityList
from flow360.component.simulation.meshing_param.params import MeshingParams
from flow360.component.simulation.meshing_param.volume_params import RotationVolume
from flow360.component.simulation.primitives import Surface
from flow360.component.simulation.simulation_params import SimulationParams


class TestBoundarySplitDefenses:
    """Tests for the multi-layer defense in Boundary Split Logic."""

    @pytest.fixture
    def mock_simulation_params(self):
        """Create a mock SimulationParams."""
        params = MagicMock(spec=SimulationParams)

        # Mock asset cache
        asset_cache = MagicMock()
        asset_cache.project_entity_info = MagicMock(spec=GeometryEntityInfo)
        params.private_attribute_asset_cache = asset_cache

        # Mock meshing (no RotationVolume by default)
        params.meshing = MagicMock(spec=MeshingParams)
        params.meshing.volume_zones = []

        return params

    def _create_mock_rotation_volume(self):
        """Helper to create a valid Mock RotationVolume with enclosed entity."""
        mock_entity = MagicMock(spec=Surface)
        mock_entity.name = "blade"

        rotation_volume = MagicMock(spec=RotationVolume)
        rotation_volume.name = "rotatingZone"
        rotation_volume.enclosed_entities = MagicMock(spec=EntityList)
        rotation_volume.enclosed_entities.stored_entities = [mock_entity]
        rotation_volume.stationary_enclosed_entities = None

        # Helper for _find_zone_name
        rv_entity = MagicMock()
        rv_entity.name = "rotatingZone"
        rotation_volume.entities = MagicMock()
        rotation_volume.entities.stored_entities = [rv_entity]

        return rotation_volume

    def test_layer_defense_no_active_rotation_volumes(self, mock_simulation_params):
        """
        Layer 2 Defense:
        If there are NO active rotation volumes in params, the provider should NOT be added.
        """
        volume_mesh_meta_data = {"zones": {}}

        # Ensure no rotation volumes
        mock_simulation_params.meshing.volume_zones = []

        lookup_table = BoundaryNameLookupTable.from_params(
            volume_mesh_meta_data, mock_simulation_params
        )

        # Assertion: Provider list should be empty
        assert len(lookup_table._providers) == 0

    def test_layer_defense_volume_mesh_entity_info(self, mock_simulation_params):
        """
        Layer 1 Defense:
        If entity info is VolumeMeshEntityInfo, the provider should NOT be added,
        even if RotationVolume exists.
        """
        volume_mesh_meta_data = {"zones": {}}

        # Setup: Valid RotationVolume
        mock_simulation_params.meshing.volume_zones = [self._create_mock_rotation_volume()]

        # Setup: VolumeMeshEntityInfo
        mock_simulation_params.private_attribute_asset_cache.project_entity_info = MagicMock(
            spec=VolumeMeshEntityInfo
        )

        lookup_table = BoundaryNameLookupTable.from_params(
            volume_mesh_meta_data, mock_simulation_params
        )

        # Assertion: Provider list should be empty
        assert len(lookup_table._providers) == 0

    def test_layer_defense_mismatched_boundary_name(self, mock_simulation_params):
        """
        Layer 3 Defense (Strict Check):
        Even if the provider IS added (because we have a valid RotationVolume),
        it should NOT intercept boundaries that look like rotating boundaries but
        were not generated by THIS provider.
        """
        # Setup: Valid RotationVolume (so provider WILL be added)
        mock_simulation_params.meshing.volume_zones = [self._create_mock_rotation_volume()]

        # Mesh metadata: contains a "suspicious" name that does NOT match the generated one
        # Generated one would be: rotatingZone/blade__rotating_rotatingZone
        suspicious_name = "farfield/sphere.lb8.ugrid__rotating_intersectingCylinder"

        volume_mesh_meta_data = {
            "zones": {
                "farfield": {"boundaryNames": [suspicious_name]},
                # We need rotatingZone present so provider doesn't crash during init
                "rotatingZone": {"boundaryNames": []},
            }
        }

        lookup_table = BoundaryNameLookupTable.from_params(
            volume_mesh_meta_data, mock_simulation_params
        )

        # Assertion 1: Provider WAS added
        assert len(lookup_table._providers) == 1
        provider = lookup_table._providers[0]
        assert isinstance(provider, RotationVolumeSplitProvider)

        # Assertion 2: Suspicious name is NOT handled by provider
        assert provider.handled_by_provider(suspicious_name) is False

        # Assertion 3: Suspicious name falls through to default logic (ZONE_PREFIX)
        base_name = "sphere.lb8.ugrid__rotating_intersectingCylinder"
        split_infos = lookup_table.get_split_info(base_name)
        assert len(split_infos) == 1
        assert split_infos[0].full_name == suspicious_name
        assert split_infos[0].split_type == SplitType.ZONE_PREFIX

    def test_provider_intercepts_correctly_generated_boundary(self, mock_simulation_params):
        """
        Happy Path:
        If RotationVolume exists AND the boundary name matches the generated one,
        it SHOULD be intercepted.
        """
        # Setup: Valid RotationVolume
        mock_simulation_params.meshing.volume_zones = [self._create_mock_rotation_volume()]

        generated_full_name = "rotatingZone/blade__rotating_rotatingZone"
        volume_mesh_meta_data = {
            "zones": {
                "rotatingZone": {
                    "boundaryNames": [
                        "rotatingZone/blade",
                        generated_full_name,
                    ]
                }
            }
        }

        lookup_table = BoundaryNameLookupTable.from_params(
            volume_mesh_meta_data, mock_simulation_params
        )

        # Assertion 1: Provider WAS added
        assert len(lookup_table._providers) == 1
        provider = lookup_table._providers[0]

        # Assertion 2: Generated name IS handled by provider
        assert provider.handled_by_provider(generated_full_name) is True

        # Assertion 3: Lookup by base name 'blade' returns the generated split info
        split_infos = lookup_table.get_split_info("blade")
        full_names = [info.full_name for info in split_infos]
        assert generated_full_name in full_names
