import json
import os

import flow360 as fl
import flow360.component.simulation.units as u
from flow360.component.geometry import Geometry, GeometryMeta
from flow360.component.resource_base import local_metadata_builder
from flow360.component.simulation.translator.solver_translator import get_solver_json


def _load_json(relative_path: str) -> dict:
    """Load a JSON file from translator test data folder."""
    test_dir = os.path.dirname(os.path.abspath(__file__))
    json_path = os.path.join(test_dir, "..", "data", "snappy_multizone", relative_path)
    with open(json_path, "r", encoding="utf-8") as file_handle:
        return json.load(file_handle)


def _expected_split_boundary_names(volume_mesh_meta_data: dict, boundary_name: str) -> list:
    """
    Return all zone-qualified boundary names generated by the mesher.

    Example:
      boundary_name = "tower::tunnel"
      -> ["fluid/tower::tunnel", "radiator/tower::tunnel"]
    """
    expected = []
    for zone_meta in volume_mesh_meta_data.get("zones", {}).values():
        for full_boundary_name in zone_meta.get("boundaryNames", []):
            if full_boundary_name.endswith(f"/{boundary_name}"):
                expected.append(full_boundary_name)
    return sorted(expected)


def test_snappy_boundary_breaking_into_multiple_pieces_translation():
    """
    If a boundary is split into multiple zone-qualified boundaries by the mesher,
    referencing the original boundary name should translate into referencing all parts.
    """
    volume_mesh_meta_data = _load_json("vm_metadata.json")

    # Create geometry from local storage simulation.json
    test_dir = os.path.dirname(os.path.abspath(__file__))
    local_storage_path = os.path.join(test_dir, "..", "data", "snappy_multizone")
    geometry = Geometry.from_local_storage(
        geometry_id="geo-snappy-multizone",
        local_storage_path=local_storage_path,
        meta_data=GeometryMeta(
            **local_metadata_builder(
                id="geo-snappy-multizone",
                name="snappy_multizone",
                cloud_path_prefix="s3_path_placeholder",
                status="processed",
            )
        ),
    )
    geometry.group_faces_for_snappy()

    # Pick two boundaries that are split across zones per vm_metadata.json
    split_boundary_names = ["tower::tunnel", "rad::int-inlet"]
    expected_split_names = {
        name: _expected_split_boundary_names(volume_mesh_meta_data, name)
        for name in split_boundary_names
    }
    assert expected_split_names == {
        "tower::tunnel": ["fluid/tower::tunnel", "radiator/tower::tunnel"],
        "rad::int-inlet": ["fluid/rad::int-inlet", "radiator/rad::int-inlet"],
    }
    for boundary_name, expected in expected_split_names.items():
        assert len(expected) > 1, f"Test data expects '{boundary_name}' to be split across zones"

    with fl.SI_unit_system:
        params_baseline = fl.SimulationParams(
            operating_condition=fl.AerospaceCondition(
                velocity_magnitude=40 * fl.u.m / fl.u.s,
            ),
            time_stepping=fl.Steady(),
            models=[
                # Reference the original (non zone-qualified) boundary names.
                fl.Wall(
                    entities=[geometry["tower::tunnel"]],
                    use_wall_function=True,
                    name="Wall-tower-tunnel",
                ),
                fl.Wall(
                    entities=[geometry["rad::int-inlet"]],
                    use_wall_function=True,
                    name="Wall-rad-int-inlet",
                ),
            ],
            reference_geometry=fl.ReferenceGeometry(),
        )

        # Translate without metadata: baseline params uses original boundary names.
        translated_baseline = get_solver_json(params_baseline, mesh_unit=1 * u.mm)

        # Apply the mesher volume mesh metadata which will multiply boundaries when needed,
        # then translate again.
        params_with_metadata = params_baseline._update_param_with_actual_volume_mesh_meta(
            volume_mesh_meta_data
        )
        translated_with_metadata = get_solver_json(params_with_metadata, mesh_unit=1 * u.mm)

    baseline_boundaries = translated_baseline.get("boundaries", {})
    translated_boundaries = translated_with_metadata.get("boundaries", {})

    for boundary_name, expected in expected_split_names.items():
        assert boundary_name in baseline_boundaries, (
            f"Baseline solver JSON is expected to contain boundary '{boundary_name}'. "
            f"Got: {sorted(baseline_boundaries.keys())}"
        )

        expected_value = baseline_boundaries[boundary_name]

        # After metadata update, the original boundary key should no longer exist.
        assert boundary_name not in translated_boundaries

        # Each mesher-generated part should exist and have exactly the same value as prime.
        for translated_boundary_name in expected:
            assert translated_boundary_name in translated_boundaries, (
                f"Boundary '{boundary_name}' should be translated to '{translated_boundary_name}'. "
                f"Got: {sorted(translated_boundaries.keys())}"
            )
            assert translated_boundaries[translated_boundary_name] == expected_value, (
                f"Boundary '{translated_boundary_name}' value mismatch.\n"
                f"Expected (from prime '{boundary_name}'): {expected_value}\n"
                f"Got: {translated_boundaries[translated_boundary_name]}"
            )
    
