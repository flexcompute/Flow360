{
  "$defs": {
    "EntityList_Surface_GhostSurface_": {
      "additionalProperties": false,
      "description": "Parameters\n----------\nstored_entities : typing.Optional[typing.List[typing.Union[flow360.component.simulation.primitives.Surface, flow360.component.simulation.primitives.GhostSurface]]]\n    ",
      "properties": {
        "stored_entities": {
          "anyOf": [
            {
              "items": {
                "anyOf": [
                  {
                    "$ref": "#/$defs/Surface"
                  },
                  {
                    "$ref": "#/$defs/GhostSurface"
                  }
                ]
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "title": "Stored Entities"
        }
      },
      "required": [
        "stored_entities"
      ],
      "title": "EntityList[Surface,GhostSurface]",
      "type": "object"
    },
    "GhostSurface": {
      "additionalProperties": false,
      "description": "Represents a boudary surface that may or may not be generated therefore may or may not exist.\nIt depends on the submitted geometry/Surface mesh. E.g. the symmetry plane in `AutomatedFarfield`.\n\nParameters\n----------\nprivate_attribute_registry_bucket_name : typing.Literal['SurfaceEntityType'] = SurfaceEntityType\n        private_attribute_entity_type_name : typing.Literal['GhostSurface'] = GhostSurface\n        name : <class 'str'>\n        private_attribute_full_name : typing.Optional[str] = None\n    \nFor now we do not use metadata or any other information to validate (on the client side) whether the surface\nactually exists. We will let workflow error out if the surface is not found.\n\n- For meshing:\n   - we forbid using `GhostSurface` in any surface-related features which is not supported right now anyways.\n\n- For boundary condition and post-processing:\n    - Allow usage of `GhostSurface` but no validation. Solver validation will error out when finding mismatch\n    between the boundary condition and the mesh meta.",
      "properties": {
        "private_attribute_registry_bucket_name": {
          "const": "SurfaceEntityType",
          "default": "SurfaceEntityType",
          "enum": [
            "SurfaceEntityType"
          ],
          "title": "Private Attribute Registry Bucket Name",
          "type": "string"
        },
        "private_attribute_entity_type_name": {
          "const": "GhostSurface",
          "default": "GhostSurface",
          "enum": [
            "GhostSurface"
          ],
          "title": "Private Attribute Entity Type Name",
          "type": "string"
        },
        "name": {
          "title": "Name",
          "type": "string"
        },
        "private_attribute_full_name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Private Attribute Full Name"
        }
      },
      "required": [
        "name"
      ],
      "title": "GhostSurface",
      "type": "object"
    },
    "Surface": {
      "additionalProperties": false,
      "description": "Represents a boudary surface in three-dimensional space.\n\n\nParameters\n----------\nprivate_attribute_registry_bucket_name : typing.Literal['SurfaceEntityType'] = SurfaceEntityType\n        private_attribute_entity_type_name : typing.Literal['Surface'] = Surface\n        name : <class 'str'>\n        private_attribute_full_name : typing.Optional[str] = None\n        private_attribute_is_interface : typing.Optional[bool] = None\n    This is required when generated from volume mesh\n    but not required when from surface mesh meta.",
      "properties": {
        "private_attribute_registry_bucket_name": {
          "const": "SurfaceEntityType",
          "default": "SurfaceEntityType",
          "enum": [
            "SurfaceEntityType"
          ],
          "title": "Private Attribute Registry Bucket Name",
          "type": "string"
        },
        "private_attribute_entity_type_name": {
          "const": "Surface",
          "default": "Surface",
          "enum": [
            "Surface"
          ],
          "title": "Private Attribute Entity Type Name",
          "type": "string"
        },
        "name": {
          "title": "Name",
          "type": "string"
        },
        "private_attribute_full_name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Private Attribute Full Name"
        },
        "private_attribute_is_interface": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "This is required when generated from volume mesh\n        but not required when from surface mesh meta.",
          "title": "Private Attribute Is Interface"
        }
      },
      "required": [
        "name"
      ],
      "title": "Surface",
      "type": "object"
    },
    "SurfaceList": {
      "additionalProperties": false,
      "description": "List of surfaces for integrals.\n\nParameters\n----------\nname : <class 'str'>\n        entities : <class 'abc.EntityList[Surface,GhostSurface]'>\n    ",
      "properties": {
        "name": {
          "title": "Name",
          "type": "string"
        },
        "surfaces": {
          "$ref": "#/$defs/EntityList_Surface_GhostSurface_"
        }
      },
      "required": [
        "name",
        "surfaces"
      ],
      "title": "SurfaceList",
      "type": "object"
    },
    "UniqueAliasedStringList_Literal_": {
      "additionalProperties": false,
      "description": "Parameters\n----------\nitems : typing.List[typing.Literal['Cp', 'gradW', 'kOmega', 'Mach', 'mut', 'mutRatio', 'nuHat', 'primitiveVars', 'qcriterion', 'residualNavierStokes', 'residualTransition', 'residualTurbulence', 's', 'solutionNavierStokes', 'solutionTransition', 'solutionTurbulence', 'T', 'vorticity', 'wallDistance', 'numericalDissipationFactor', 'residualHeatSolver', 'VelocityRelative', 'lowMachPreconditionerSensor']]\n    ",
      "properties": {
        "items": {
          "items": {
            "enum": [
              "Cp",
              "gradW",
              "kOmega",
              "Mach",
              "mut",
              "mutRatio",
              "nuHat",
              "primitiveVars",
              "qcriterion",
              "residualNavierStokes",
              "residualTransition",
              "residualTurbulence",
              "s",
              "solutionNavierStokes",
              "solutionTransition",
              "solutionTurbulence",
              "T",
              "vorticity",
              "wallDistance",
              "numericalDissipationFactor",
              "residualHeatSolver",
              "VelocityRelative",
              "lowMachPreconditionerSensor"
            ],
            "type": "string"
          },
          "title": "Items",
          "type": "array"
        }
      },
      "required": [
        "items"
      ],
      "title": "UniqueAliasedStringList[Literal]",
      "type": "object"
    },
    "UniqueItemList_SurfaceList_": {
      "additionalProperties": false,
      "description": "Parameters\n----------\nitems : typing.List[flow360.component.simulation.outputs.output_entities.SurfaceList]\n    ",
      "properties": {
        "items": {
          "items": {
            "$ref": "#/$defs/SurfaceList"
          },
          "title": "Items",
          "type": "array"
        }
      },
      "required": [
        "items"
      ],
      "title": "UniqueItemList[SurfaceList]",
      "type": "object"
    }
  },
  "additionalProperties": false,
  "description": "Surface integral output settings.\n\nParameters\n----------\nfrequency : <class 'int'> = -1\n    Frequency (in number of physical time steps) at which output is saved.\n    -1 is at end of simulation.\nfrequency_offset : <class 'int'> = 0\n    Offset (in number of physical time steps) at which output animation is started.\n    0 is at beginning of simulation.\nname : typing.Optional[str] = None\n        entities : typing.Optional[abc.UniqueItemList[SurfaceList]] = None\n        output_fields : <class 'abc.UniqueAliasedStringList[Literal]'>\n        output_type : typing.Literal['SurfaceIntegralOutput'] = SurfaceIntegralOutput\n    ",
  "properties": {
    "frequency": {
      "default": -1,
      "description": "Frequency (in number of physical time steps) at which output is saved.\n        -1 is at end of simulation.",
      "minimum": -1,
      "title": "Frequency",
      "type": "integer"
    },
    "frequency_offset": {
      "default": 0,
      "description": "Offset (in number of physical time steps) at which output animation is started.\n        0 is at beginning of simulation.",
      "minimum": 0,
      "title": "Frequency Offset",
      "type": "integer"
    },
    "name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Name"
    },
    "monitors": {
      "anyOf": [
        {
          "$ref": "#/$defs/UniqueItemList_SurfaceList_"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "output_fields": {
      "$ref": "#/$defs/UniqueAliasedStringList_Literal_"
    },
    "output_type": {
      "const": "SurfaceIntegralOutput",
      "default": "SurfaceIntegralOutput",
      "enum": [
        "SurfaceIntegralOutput"
      ],
      "title": "Output Type",
      "type": "string"
    }
  },
  "required": [
    "output_fields"
  ],
  "title": "SurfaceIntegralOutput",
  "type": "object"
}